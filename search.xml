<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java GC</title>
    <url>/2020/06/23/gc/</url>
    <content><![CDATA[<h2 id="垃圾收集器组合"><a href="#垃圾收集器组合" class="headerlink" title="垃圾收集器组合"></a>垃圾收集器组合</h2><p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="image-20200721001441463"></p>
]]></content>
      <categories>
        <category>Java GC</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发基础</title>
    <url>/2020/02/23/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Java并发基础"><a href="#Java并发基础" class="headerlink" title="Java并发基础"></a>Java并发基础</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h4><p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的</strong>。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p><strong>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</strong><a id="more"></a></p>
<h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h4><p>线程与进程相似，<strong>但线程是一个比进程更小的执行单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h4 id="请简要描述线程与进程的关系-区别及优缺点"><a href="#请简要描述线程与进程的关系-区别及优缺点" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点"></a>请简要描述线程与进程的关系,区别及优缺点</h4><!--![](D:\github\source\_posts\P}$JF5JJ7`A1)]~HZF$PAJ2.png)-->

<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong> (JDK1.8 之后的<strong>元空间</strong>)资源，但是每个线程有自己的*<em>程序计数器*</em>、<strong>虚拟机栈 和 **本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上<strong>各进程是独立的</strong>，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h4><p>程序计数器主要有下面两个作用：</p>
<ol>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
</li>
<li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
</li>
</ol>
<h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h4><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>​       为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<p><strong>堆和方法区</strong>是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h4 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h4><ul>
<li><strong>并发：</strong> 同一时间段，多个任务<strong>都在</strong>执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务<strong>同时</strong>执行。</li>
</ul>
<h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h4 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h4><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、上下文切换、死锁</strong>还有受限于硬件和软件的资源闲置问题。</p>
<h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h4 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>当线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，此时这两个线程就会互相等待而进入死锁状态。</p>
<!-- ![](D:\github\source\_posts\QGB]6)$MU~~0@WM_@(926L3.png) -->


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    private static Object resource1 &#x3D; new Object();&#x2F;&#x2F;资源 1</span><br><span class="line">    private static Object resource2 &#x3D; new Object();&#x2F;&#x2F;资源 2</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;waiting get resource2&quot;);</span><br><span class="line">                synchronized (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程 1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;waiting get resource1&quot;);</span><br><span class="line">                synchronized (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程 2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程 1get resource1</span><br><span class="line">线程 2get resource2</span><br><span class="line">线程 1waiting get resource2</span><br><span class="line">线程 2waiting get resource1</span><br></pre></td></tr></table></figure>

<p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    synchronized (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;get resource1&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);</span><br><span class="line">        synchronized (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot;get resource2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;线程 2&quot;).start();</span><br></pre></td></tr></table></figure>



<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p>
<!-- ![](D:\github\source\_posts\OS16]DR4{Q}PMZJMAIOLI6X.png) -->


<p><strong>新建（New）</strong>：创建后尚未启动的线程处于这种状态；<br><strong>运行（Runnable）</strong>：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间；<br><strong>无限期等待（Waiting）</strong>：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其它线程显式地唤醒；以下三种方法会让线程进入无限期等待状态：<br>没有设置 TimeOut 参数的 Object.wait()；<br>没有设置 TimeOut 参数的 Thread.join()；<br>LockSupport.park()。<br><strong>限期等待（Timed Waiting）</strong>：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒；以下方法会让线程进入限期等待状态：<br>Thread.sleep()；<br>设置了 TimeOut 参数的 Object.wait()；<br>设置了 TimeOut 参数的 Thread.join()；<br>LockSupport.parkNanos()；<br>LockSupport.parkUntil()。<br><strong>阻塞（Blocked）</strong>：线程被阻塞了，「阻塞状态」和「等待状态」的区别是：「阻塞状态」在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发送。在程序等待进入同步区域时，线程将进入这种状态；<br><strong>结束（Terminated）</strong>：线程已经结束执行。</p>
<h4 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点?"></a>sleep() 方法和 wait() 方法区别和共同点?</h4><ul>
<li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
]]></content>
      <categories>
        <category>Java JUC</category>
      </categories>
      <tags>
        <tag>Java JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/10/11/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表之链表中倒数第k个节点"><a href="#链表之链表中倒数第k个节点" class="headerlink" title="链表之链表中倒数第k个节点"></a>链表之链表中倒数第k个节点</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ul>
<li>第一时间想到的解法：<ul>
<li>先遍历统计链表长度，记为 n ；</li>
<li>设置一个指针走 (n-k) 步，即可找到链表倒数第 k 个节点。</li>
</ul>
</li>
<li>使用双指针则可以不用统计链表长度。<ul>
<li>初始化： 快指针 <code>fast</code> 、慢指针 <code>slow</code> ，双指针都指向头节点 <code>head</code>​ 。</li>
<li>构建双指针距离： 快指针 <code>fast</code> 先向前走 k 步（结束后，双指针 <code>fast</code> 和 <code>slow</code> 间相距 k 步）。</li>
<li>双指针共同移动： 循环中，双指针 <code>fast</code> 和 <code>slow</code> 每轮都向前走一步，直至 <code>fast</code> 走过链表 尾节点 时跳出（跳出后， <code>slow</code> 与尾节点距离为 k−1，即 <code>slow</code> 指向倒数第 k 个节点）。</li>
<li>返回值： 返回 <code>slow</code> 即可。</li>
</ul>
</li>
</ul>
<p><strong>下面采用双指针的方法进行求解</strong></p>
<p><strong>双指针复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为链表长度；总体看， <code>fast</code> 走了 N 步， <code>slow</code> 走了 (N-k) 步。</li>
<li>空间复杂度 O(1) ： 双指针 <code>fast</code> , <code>slow</code> 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode getKthFromEnd(ListNode head, int k) &#123;</span><br><span class="line">        ListNode fast &#x3D; head, slow &#x3D; head;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; null) return null;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast!&#x3D;null)&#123;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表之两个链表的第一个公共节点"><a href="#链表之两个链表的第一个公共节点" class="headerlink" title="链表之两个链表的第一个公共节点"></a>链表之两个链表的第一个公共节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共节点。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们使用两个指针 <code>ptr1</code>，<code>ptr2</code> 分别指向两个链表 <code>headA</code>，<code>headB</code> 的头结点，<br>然后同时分别逐结点遍历，当 <code>ptr1</code> 到达链表 <code>headA</code> 的末尾时，<br>重新定位到链表 <code>headB</code> 的头结点；当 <code>ptr2</code> 到达链表 <code>headB</code> 的末尾时，重新定位到链表 <code>headA</code> 的头结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val &#x3D; x;</span><br><span class="line"> *         next &#x3D; null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode ptr1 &#x3D; headA, ptr2 &#x3D; headB;</span><br><span class="line">        while(ptr1 !&#x3D; ptr2)&#123;</span><br><span class="line">            ptr1 &#x3D; ptr1 &#x3D;&#x3D; null?headB:ptr1.next;</span><br><span class="line">            ptr2 &#x3D; ptr2 &#x3D;&#x3D; null?headA:ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表之反转链表"><a href="#链表之反转链表" class="headerlink" title="链表之反转链表"></a>链表之反转链表</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>双指针求解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre &#x3D; null, preOfPre &#x3D; null, cur &#x3D; head;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            pre &#x3D; cur;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">            pre.next &#x3D; preOfPre;</span><br><span class="line">            preOfPre &#x3D; pre;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表之删除链表的节点"><a href="#链表之删除链表的节点" class="headerlink" title="链表之删除链表的节点"></a>链表之删除链表的节点</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>引入哨兵节点prior，减少情况讨论</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteNode(ListNode head, int val) &#123;</span><br><span class="line">        ListNode prior &#x3D; new ListNode(-1);</span><br><span class="line">        prior.next &#x3D; head;</span><br><span class="line">        ListNode ptr &#x3D; prior;</span><br><span class="line">        while(ptr.next!&#x3D;null &amp;&amp; ptr.next.val !&#x3D; val)&#123;</span><br><span class="line">            ptr &#x3D; ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ptr.next !&#x3D; null)&#123;</span><br><span class="line">            ptr.next &#x3D; ptr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return prior.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表之复杂链表的复制"><a href="#链表之复杂链表的复制" class="headerlink" title="链表之复杂链表的复制"></a>链表之复杂链表的复制</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，<br>每个节点除了有一个 <code>next</code> 指针指向下一个节点，<br>还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">&#x2F;&#x2F; Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    public Node(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.next &#x3D; null;</span><br><span class="line">        this.random &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null) return null;</span><br><span class="line">        Node ptr &#x3D; head;</span><br><span class="line">        while(ptr !&#x3D; null)&#123;</span><br><span class="line">            Node tmp &#x3D; new Node(ptr.val);</span><br><span class="line">            tmp.next &#x3D; ptr.next;</span><br><span class="line">            ptr.next &#x3D; tmp;</span><br><span class="line">            ptr &#x3D; ptr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr &#x3D; head;</span><br><span class="line">        while(ptr!&#x3D;null)&#123;</span><br><span class="line">            if(ptr.random!&#x3D;null)&#123;</span><br><span class="line">                ptr.next.random &#x3D; ptr.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ptr &#x3D; ptr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr &#x3D; head;</span><br><span class="line">        Node res &#x3D; ptr.next;</span><br><span class="line">        while(ptr!&#x3D;null)&#123;</span><br><span class="line">            Node tmp &#x3D; ptr.next;</span><br><span class="line">            ptr.next &#x3D; ptr.next.next;</span><br><span class="line">            if(tmp.next!&#x3D;null)&#123;</span><br><span class="line">                tmp.next &#x3D; tmp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr &#x3D; ptr.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/01/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="实现Runnable接口和Callable接口的区别"><a href="#实现Runnable接口和Callable接口的区别" class="headerlink" title="实现Runnable接口和Callable接口的区别"></a>实现Runnable接口和Callable接口的区别</h4><p><code>Runnable</code>自Java 1.0以来一直存在，但<code>Callable</code>仅在Java 1.5中引入,<br>目的就是为了来处理<code>Runnable</code>不支持的用例。<br><code>Runnable</code> 接口不会返回结果或抛出检查异常，<br>但是<code>Callable</code> 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> 接口，<br>这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。<br>（<code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<h4 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h4><ul>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，<br>通过这个 <code>Future</code> 对象可以判断任务是否执行成功，</strong><br>并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，<br>而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，<br>而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<p><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。<br><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</p>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><strong>方式二：通过Executor 框架的工具类Executors来实现</strong> 我们可以创建三种类型的ThreadPoolExecutor：</p>
<ul>
<li>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<h4 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h4><p><code>ThreadPoolExecutor</code>类中提供的四个构造方法。我们来看最长的那个，<br>其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadPoolExecutor</code><strong>构造函数重要参数分析</strong></p>
<p><code>ThreadPoolExecutor</code><strong>3 个最重要的参数</strong>：</p>
<ul>
<li><code>corePoolSize</code> : 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><code>maximumPoolSize</code> : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><code>workQueue</code>: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ul>
<li><code>keepAliveTime</code>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，<br>而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><code>threadFactory</code> :<code>executor</code> 创建新线程的时候会用到。</li>
<li><code>handler</code> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<p><code>ThreadPoolExecutor</code> <strong>饱和策略</strong><br><code>ThreadPoolExecutor</code> <strong>饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：<strong>调用执行自己的线程运行任务</strong>。您不会任务请求。<br>但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。<br>如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>： 不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。<br>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，<br>当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。<br>在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。<br>对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。<br>（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</li>
</ul>
]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p>
<ul>
<li>常见的 DFS ： 先序遍历、中序遍历、后序遍历；</li>
<li>常见的 BFS ： 层序遍历（即按层遍历）。</li>
</ul>
<h3 id="二叉树之二叉树的深度"><a href="#二叉树之二叉树的深度" class="headerlink" title="二叉树之二叉树的深度"></a>二叉树之二叉树的深度</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h4 id="Java非递归版本-层次遍历（BFS）"><a href="#Java非递归版本-层次遍历（BFS）" class="headerlink" title="Java非递归版本-层次遍历（BFS）"></a>Java非递归版本-层次遍历（BFS）</h4><ul>
<li>树的层序遍历 / 广度优先搜索往往利用<strong>队列</strong>实现。</li>
<li>关键点： 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li><strong>特例处理</strong>： 当 <code>root</code>​ 为空，直接返回 深度 0 。</li>
<li><strong>初始化</strong>： 队列 <code>queue</code> （加入根节点 <code>root</code> ），计数器 <code>res = 0</code>。</li>
<li><strong>循环遍历</strong>： 当 <code>queue</code> 为空时跳出。<ul>
<li>1 初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点；</li>
<li>2 遍历队列： 遍历 <code>queue</code> 中的各节点 <code>node</code> ，并将其左子节点和右子节点加入 tmp；</li>
<li>3 更新队列： 执行 <code>queue = tmp</code> ，将下一层节点赋值给 <code>queue</code>；</li>
<li>4 统计层数： 执行 <code>res += 1</code> ，代表层数加 1；</li>
</ul>
</li>
<li><strong>返回值</strong>： 返回 <code>res</code> 即可。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 <code>queue</code> 同时存储 N/2 个节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        List&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            tmp &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">            for(TreeNode node : queue) &#123;</span><br><span class="line">                if(node.left !&#x3D; null) tmp.add(node.left);</span><br><span class="line">                if(node.right !&#x3D; null) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue &#x3D; tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java递归版本-后序遍历"><a href="#Java递归版本-后序遍历" class="headerlink" title="Java递归版本-后序遍历"></a>Java递归版本-后序遍历</h4><ul>
<li>树的后序遍历 / 深度优先搜索往往利用<strong>递归</strong>或<strong>栈</strong>实现，本文使用递归实现。</li>
<li><strong>关键点</strong>： 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong>等于<strong>左子树的深度</strong>与<strong>右子树的深度</strong>中的<strong>最大值</strong>+1。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li>终止条件： 当 <code>root</code>​ 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li>递推工作： 本质上是对树做后序遍历。<ul>
<li>1 计算节点 <code>root​</code> 的 左子树的深度 ，即调用 <code>maxDepth(root.left)</code>；</li>
<li>2 计算节点 <code>root</code>​ 的 右子树的深度 ，即调用 <code>maxDepth(root.right)</code>；</li>
</ul>
</li>
<li>返回值： 返回 此树的深度 ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int leftDepth &#x3D; maxDepth(root.left);</span><br><span class="line">        int rightDepth &#x3D; maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之对称的二叉树"><a href="#二叉树之对称的二叉树" class="headerlink" title="二叉树之对称的二叉树"></a>二叉树之对称的二叉树</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：<ul>
<li>L.val=R.val ：即此两对称节点值相等。</li>
<li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>
</ul>
<p><strong>算法流程</strong><br><code>isSymmetric(root)</code> ：</p>
<ul>
<li>特例处理： 若根节点 <code>root</code> 为空，则直接返回 true 。</li>
<li>返回值： 即 <code>recu(root.left, root.right)</code> ;</li>
</ul>
<p><code>recu(L, R)</code></p>
<ul>
<li>终止条件：<ul>
<li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；<br>当节点 L 值 != 节点 R 值： 此树不对称，因此返回 false ；</li>
</ul>
</li>
<li>递推工作：<ul>
<li>判断两节点 L.left 和 R.right 是否对称，即 <code>recu(L.left, R.right)</code> ；</li>
<li>判断两节点 L.right 和 R.left 是否对称，即 <code>recu(L.right, R.left)</code> ；</li>
</ul>
</li>
<li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li>
</ul>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 <code>recu()</code> 可以判断一对节点是否对称，因此最多调用 N/2 次 <code>recu()</code> 方法。</li>
<li>空间复杂度 O(N) ： 最差情况下，二叉树退化为链表，系统使用 O(N) 大小的栈空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return true;</span><br><span class="line">        return recu(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean recu(TreeNode root1, TreeNode root2)&#123;</span><br><span class="line">        if(root1 &#x3D;&#x3D; null &amp;&amp; root2 &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null) return false;</span><br><span class="line">        if(root1.val !&#x3D; root2.val) return false;</span><br><span class="line">        return recu(root1.left, root2.right) &amp;&amp; recu(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之平衡二叉树"><a href="#二叉树之平衡二叉树" class="headerlink" title="二叉树之平衡二叉树"></a>二叉树之平衡二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p><strong>二叉树的深度的扩展</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private boolean res &#x3D; true;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return true;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private int dfs(TreeNode node)&#123;</span><br><span class="line">        if(res &#x3D;&#x3D; false) return -1;</span><br><span class="line">        if(node &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int leftDepth &#x3D; dfs(node.left);</span><br><span class="line">        int rightDepth &#x3D; dfs(node.right);</span><br><span class="line">        if(Math.abs(leftDepth - rightDepth) &gt; 1)&#123;</span><br><span class="line">            res &#x3D; false;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之重建二叉树"><a href="#二叉树之重建二叉树" class="headerlink" title="二叉树之重建二叉树"></a>二叉树之重建二叉树</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        System.out.println(preorder);</span><br><span class="line">        if (preorder.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; preorder.length;</span><br><span class="line">        int rootVal &#x3D; preorder[0];</span><br><span class="line">        TreeNode ptr &#x3D; new TreeNode(rootVal);</span><br><span class="line">        int rootValIndex &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (rootVal &#x3D;&#x3D; inorder[i])&#123;</span><br><span class="line">                rootValIndex &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] preorder1 &#x3D; Arrays.copyOfRange(preorder, 1, 1 + rootValIndex);</span><br><span class="line">        int[] preorder2 &#x3D; Arrays.copyOfRange(preorder, 1 + rootValIndex, len);</span><br><span class="line">        int[] inorder1 &#x3D; Arrays.copyOfRange(inorder, 0, rootValIndex);</span><br><span class="line">        int[] inorder2 &#x3D; Arrays.copyOfRange(inorder, 1+rootValIndex, len);</span><br><span class="line">        ptr.left &#x3D; buildTree(preorder1, inorder1);</span><br><span class="line">        ptr.right &#x3D; buildTree(preorder2, inorder2);</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>改进，引入哈希表，以空间换时间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     &#x2F;&#x2F; 改进，特征输入用例的考虑，如输入数组为空， 输入数组长度不一</span><br><span class="line">     &#x2F;&#x2F;加入哈希表，以空间换时间</span><br><span class="line">    private Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private int[] preorder;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if (preorder &#x3D;&#x3D; null || preorder.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int len1 &#x3D; preorder.length;</span><br><span class="line">        int len2 &#x3D; inorder.length;</span><br><span class="line">        if (len1 !&#x3D; len2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        this.preorder &#x3D; preorder;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len1; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return recu(0, len1-1, 0, len2-1);</span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode recu(int preL, int preR, int inL, int inR) &#123;</span><br><span class="line">        if (preL &gt; preR)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode ptr &#x3D;  new TreeNode(preorder[preL]);</span><br><span class="line">       </span><br><span class="line">        int indexIn &#x3D; map.get(preorder[preL]); </span><br><span class="line">        ptr.left &#x3D; recu(preL+1, preL + indexIn - inL, inL, indexIn - 1);</span><br><span class="line">        ptr.right &#x3D; recu(preL + indexIn - inL + 1, preR, indexIn + 1, inR);</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之-之字形打印二叉树"><a href="#二叉树之-之字形打印二叉树" class="headerlink" title="二叉树之 之字形打印二叉树"></a>二叉树之 之字形打印二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>求解：层次遍历 + 双端队列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; deque &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        boolean pos &#x3D; true;</span><br><span class="line">        while(!deque.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            int length &#x3D; deque.size();</span><br><span class="line">            if(pos &#x3D;&#x3D; true)&#123;</span><br><span class="line">                for(int i &#x3D; 0;i &lt; length; i++)&#123;</span><br><span class="line">                    TreeNode poped &#x3D; deque.pollFirst();</span><br><span class="line">                    tmp.add(poped.val);</span><br><span class="line">                    if(poped.left!&#x3D;null) deque.addLast(poped.left);</span><br><span class="line">                    if(poped.right!&#x3D;null) deque.addLast(poped.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for(int i &#x3D; 0;i &lt; length; i++)&#123;</span><br><span class="line">                    TreeNode poped &#x3D; deque.pollLast();</span><br><span class="line">                    tmp.add(poped.val);</span><br><span class="line">                    if(poped.right!&#x3D;null) deque.addFirst(poped.right);</span><br><span class="line">                    if(poped.left!&#x3D;null) deque.addFirst(poped.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            pos &#x3D; !pos;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之树的子结构"><a href="#二叉树之树的子结构" class="headerlink" title="二叉树之树的子结构"></a>二叉树之树的子结构</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值<br><strong>非递归</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;</span><br><span class="line">        if(A &#x3D;&#x3D; null || B &#x3D;&#x3D; null) return false;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        TreeNode ptr &#x3D; A;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line">        while(!stack.isEmpty() || ptr !&#x3D; null)&#123;</span><br><span class="line">            if (ptr !&#x3D; null) res &#x3D; isSub(ptr, B);</span><br><span class="line">            if(res &#x3D;&#x3D; true) &#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ptr!&#x3D;null)&#123;</span><br><span class="line">                stack.push(ptr);</span><br><span class="line">                ptr &#x3D; ptr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                TreeNode poped &#x3D; stack.pop();</span><br><span class="line">                ptr &#x3D; poped.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isSub(TreeNode ptr, TreeNode B)&#123;</span><br><span class="line">        if(B &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(ptr &#x3D;&#x3D; null || ptr.val !&#x3D; B.val) return false;</span><br><span class="line">        else return isSub(ptr.left, B.left) &amp;&amp; isSub(ptr.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;</span><br><span class="line">        if(A &#x3D;&#x3D; null || B &#x3D;&#x3D; null) return false;</span><br><span class="line">        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isSub(TreeNode ptr, TreeNode B)&#123;</span><br><span class="line">        if(B &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(ptr &#x3D;&#x3D; null || ptr.val !&#x3D; B.val) return false;</span><br><span class="line">        else return isSub(ptr.left, B.left) &amp;&amp; isSub(ptr.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之二叉树中和为某一值的路径"><a href="#二叉树之二叉树中和为某一值的路径" class="headerlink" title="二叉树之二叉树中和为某一值的路径"></a>二叉树之二叉树中和为某一值的路径</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    Stack&lt;Integer&gt; path &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        </span><br><span class="line">        ptr_Search(root, sum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ptr_Search(TreeNode ptr, int sum) &#123;</span><br><span class="line">        if (ptr &#x3D;&#x3D; null) return;</span><br><span class="line">        path.push(ptr.val);</span><br><span class="line">        sum -&#x3D; ptr.val;</span><br><span class="line">        if (sum &#x3D;&#x3D; 0 &amp;&amp; ptr.left &#x3D;&#x3D; null &amp;&amp; ptr.right &#x3D;&#x3D; null)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            path.pop();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr_Search(ptr.left, sum);</span><br><span class="line">        ptr_Search(ptr.right, sum);</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之二叉树的最近公共祖先"><a href="#二叉树之二叉树的最近公共祖先" class="headerlink" title="二叉树之二叉树的最近公共祖先"></a>二叉树之二叉树的最近公共祖先</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    private TreeNode res &#x3D; null;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        pre_search(root, p, q);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private int pre_search(TreeNode root, TreeNode p, TreeNode q)&#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        if(res !&#x3D; null) return 0;</span><br><span class="line">        int left &#x3D; pre_search(root.left, p, q);</span><br><span class="line">        int right &#x3D; pre_search(root.right, p, q);</span><br><span class="line">        int tmp &#x3D; 0;</span><br><span class="line">        if(root &#x3D;&#x3D; p || root &#x3D;&#x3D; q)&#123;</span><br><span class="line">            tmp &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; tmp + left + right;</span><br><span class="line">        if(sum &gt;&#x3D; 2)&#123;</span><br><span class="line">            res &#x3D; root;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之二叉搜索树的第k大节点"><a href="#二叉树之二叉搜索树的第k大节点" class="headerlink" title="二叉树之二叉搜索树的第k大节点"></a>二叉树之二叉搜索树的第k大节点</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int kthLargest(TreeNode root, int k) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        TreeNode ptr &#x3D; root, poped;</span><br><span class="line">        while(!stack.isEmpty() || ptr !&#x3D; null)&#123;</span><br><span class="line">            while(ptr !&#x3D; null)&#123;</span><br><span class="line">                stack.add(ptr);</span><br><span class="line">                ptr &#x3D; ptr.right;</span><br><span class="line">            &#125;</span><br><span class="line">            poped &#x3D; stack.pop();</span><br><span class="line">            k -&#x3D; 1;</span><br><span class="line">            if(k &#x3D;&#x3D; 0) return poped.val;</span><br><span class="line">            ptr &#x3D; poped.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList和LinkedList</title>
    <url>/2020/04/16/ArrayList%E5%92%8CLinkedList/</url>
    <content><![CDATA[<p>最近看了ArrayList和LinkedList的源码，在此记录一下他们之间的区别。</p>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><ul>
<li>ArrayList底层基于动态数组实现，LinkedList底层基于链表实现</li>
<li>对于随机访问（get/set方法），ArrayList通过index直接定位到数组对应位置的节点，而LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，因此在效率上ArrayList优于LinkedList。</li>
<li>3）对于插入和删除（add/remove方法），ArrayList需要移动目标节点后面的节点（使用System.arraycopy方法移动节点），而LinkedList只需修改目标节点前后节点的next或prev属性即可，因此在效率上LinkedList优于ArrayList。</li>
<li>当 ArrayList 是顺序插入的时候，由于<strong>不需要移动节点</strong>，因此在效率上并不会比 LinkedList 差。</li>
<li>对于随机操作的add和remove，ArrayList并不一定比LinkedList慢（ArrayList底层由于是动态数组，因此并不是每次add和remove的时候<strong>都需要创建新数组</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀项目云端部署</title>
    <url>/2019/12/11/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Java环境安装"><a href="#Java环境安装" class="headerlink" title="Java环境安装"></a>Java环境安装</h1><h2 id="下载jdk并复制到云端"><a href="#下载jdk并复制到云端" class="headerlink" title="下载jdk并复制到云端"></a>下载jdk并复制到云端</h2><p>下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p><code>tar -zxvf jdk-8u212-linux-x64.tar.gz</code></p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">#在文件末尾追加以下内容</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_261</span><br><span class="line">export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib:$JAVA_HOME&#x2F;jre&#x2F;lib:$CLASSPATH</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<h2 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>

<h2 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h2><h1 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h1><h2 id="云端Ubuntu18-04安装MySQL8-0数据库："><a href="#云端Ubuntu18-04安装MySQL8-0数据库：" class="headerlink" title="云端Ubuntu18.04安装MySQL8.0数据库："></a>云端Ubuntu18.04安装MySQL8.0数据库：</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li>Ubuntu16.04输入<code>apt-get install mysql*</code>即可安装MySQL 5.7</li>
<li>sudo apt install mysql-server 的方式 默认安装的是MySQL 5.7<br>MySQL5.7版本最高只适配到Ubuntu17.04，不支持Ubuntu18.04,若要适配需进行额外的配置<br>MySQL8.0可适配到Ubuntu18.04</li>
<li>如果系统使用的Ubuntu18.04安装MySQL8.0,加密方式需要选择5.x的加密，因为有兼容性问题</li>
<li>如果你已经执行了上边的命令，安装了MySQL5.7，需要先卸载<br><code>apt-get remove mysql-server</code></li>
</ul>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="MySQL5-7"><a href="#MySQL5-7" class="headerlink" title="MySQL5.7"></a>MySQL5.7</h4><ul>
<li><p>安装<code>apt-get install mysql*</code></p>
</li>
<li><p>设置root密码</p>
<blockquote>
<p>mysql5.7安装完成后普通用户不能进mysql，原因：root的plugin被修改成了auth_socket，用密码登陆的plugin应该是mysql_native_password，直接用root权限登录就不用密码,修改root密码和登录验证方式：</p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql</span></span><br><span class="line"><span class="meta">mysql&gt;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select user, plugin from mysql.user;</span></span><br><span class="line">+------------------+-----------------------+</span><br><span class="line">| user             | plugin                |</span><br><span class="line">+------------------+-----------------------+</span><br><span class="line">| root             | auth_socket           |</span><br><span class="line">| mysql.session    | mysql_native_password |</span><br><span class="line">| mysql.sys        | mysql_native_password |</span><br><span class="line">| debian-sys-maint | mysql_native_password |</span><br><span class="line">+------------------+-----------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update mysql.user <span class="built_in">set</span> authentication_string=PASSWORD(<span class="string">'123456'</span>), plugin=<span class="string">'mysql_native_password'</span> <span class="built_in">where</span> user=<span class="string">'root'</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">Bye</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/mysql restart</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -uroot -p</span></span><br><span class="line"></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.22-0ubuntu18.04.1 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="MySQL8-X"><a href="#MySQL8-X" class="headerlink" title="MySQL8.X"></a>MySQL8.X</h4><ul>
<li><p>首先点击进入<a href="https://dev.mysql.com/downloads/repo/apt/" target="_blank" rel="noopener">官网</a>，划到底部，下载个deb格式文件</p>
<blockquote>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814154034.png" alt="img"></p>
</blockquote>
</li>
<li><p>将下载的文件通过scp复制到tmp目录，cd进入并执行如下命令：<code>dpkg -i mysql-apt-config_0.8.10-1_all.deb</code></p>
</li>
<li><p>方向键选mysql-8.0 并按enter键</p>
<blockquote>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814154057.png" alt="img"></p>
</blockquote>
</li>
<li><p>再次方向键选择mysql-8.0 并按enter键</p>
<blockquote>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814154117.png" alt="img"></p>
</blockquote>
</li>
<li><p>方向键选择ok 并按enter键</p>
<blockquote>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814154129.png" alt="img"></p>
</blockquote>
</li>
<li><p>更新apt: <code>apt update</code></p>
</li>
<li><p>解决提示部分：<code>apt-get upgrade</code></p>
</li>
<li><p>正式安装MySQL18.04：<code>apt install mysql-server</code></p>
</li>
<li><p>上边安装完后，会让你设置root密码，输入后按enter键，并再次确认</p>
<blockquote>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814154140.png" alt="img"></p>
</blockquote>
</li>
</ul>
<ul>
<li><p>MySQL8.0采用了新的加密方式，与Ubuntu18.04有兼容问题；<br>故选择下面的旧版本5.x的加密方式</p>
<blockquote>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814154151.png" alt="img"></p>
</blockquote>
</li>
<li><p>登录输入用户名与密码，看是否安装成功<code>mysql -uroot -p</code></p>
</li>
</ul>
<h3 id="配置MySQL远程登录"><a href="#配置MySQL远程登录" class="headerlink" title="配置MySQL远程登录"></a>配置MySQL远程登录</h3><p>并不是所有知道ip和端口号以及数据库的用户名和密码的都可以远程访问数据库，还需添加白名单，在这里，为了方便起见，授权只要知道用户名和密码的均可访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改配置文件，注释掉bind-address &#x3D; 127.0.0.1</span><br><span class="line">$ sudo vi &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line"># 保存退出，然后进入mysql服务，执行授权命令：</span><br><span class="line">$ mysql -uroot -p</span><br><span class="line">#授予所有的权限（包括所有的数据库和表）给root用户所有的host，但是需要知道密码为&#39;123456&#39;</span><br><span class="line">mysql&gt; grant all on *.* to root@&#39;%&#39; identified by &#39;123456&#39; with grant option;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; exit</span><br><span class="line">Bye</span><br><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;mysql restart</span><br><span class="line"></span><br><span class="line">telnet 数据库ip 3306</span><br></pre></td></tr></table></figure>



<h2 id="数据库数据迁移"><a href="#数据库数据迁移" class="headerlink" title="数据库数据迁移"></a>数据库数据迁移</h2><ul>
<li>导出本地数据库</li>
</ul>
<p><code>/usr/local/mysql/bin/mysqldump -uroot -proot --databases miaoshademo &gt; ~/Downloads/miaosha.sql</code></p>
<ul>
<li>通过scp将本地的miaosha.sql复制到云端的tmp文件夹中</li>
<li>云端导入数据库</li>
</ul>
<p><code>mysql -uroot -proot &lt; /tmp/miaosha.sql</code></p>
<h1 id="项目迁移"><a href="#项目迁移" class="headerlink" title="项目迁移"></a>项目迁移</h1><h2 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h2><ul>
<li>进入项目根目录，终端输入<code>mvn clean package</code>打包</li>
<li>此时，在target目录下会有XXX-1.0-SNAPSHOT.jar，输入<code>java -jar XXX-1.0-SNAPSHOT.jar</code>运行，查看是否有问题</li>
</ul>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><ul>
<li>scp上传到云端，<code>java -jar XXX-1.0-SNAPSHOT.jar</code>启动程序后，输入ip:port来测试程序是否有问题</li>
</ul>
<h2 id="外挂配置文件"><a href="#外挂配置文件" class="headerlink" title="外挂配置文件"></a>外挂配置文件</h2><p>考虑到application.properties中的配置随机都会变化 ，如果每次都改动源码，将application.properties中的配置根据不同的环境进行不同的编写，然后重新编译打包部署，就会变得很低效。这就需要用到外挂配置文件了，即程序启动时，先读取程序内部的配置文件，在读取外挂配置文件，外挂配置文件的优先级高于内部配置文件，对于重复的key会冲掉对应的value。SpringBoot其实提供给我们了这样的一个运行方式。</p>
<ul>
<li>在项目jar包的同级目录下新建application.properties。在里面填入想要覆盖的配置</li>
<li>然后启动程序时新增参数<code>java -jar miaosha.jar --spring.config.addition-location=./application.properties#即外挂配置文件地址</code></li>
</ul>
<h2 id="编写deploy脚本"><a href="#编写deploy脚本" class="headerlink" title="编写deploy脚本"></a>编写deploy脚本</h2><p>为了避免每次在运行jar程序的时候都输入这么长的参数，我们可以把这些参数放在一个shell脚本里，通过shell脚本来运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi deploy.sh</span><br><span class="line"># 在脚本里写入</span><br><span class="line">nohup java -Xms400m -Xmx400m -XX:NewSize&#x3D;200m -XX:MaxNewSize&#x3D;200m -jar miaosha.jar --spring.config.additoin-location&#x3D;&#x2F;var&#x2F;www&#x2F;miaosha&#x2F;application.properties</span><br><span class="line"># 我们可以通过运行shell来启动jar程序，此时因为加了nphup，程序的输出参数会自动加入到nohup.out中</span><br><span class="line">.&#x2F;deploy.sh &amp;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>秒杀</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>定制化内嵌Tomcat开发</title>
    <url>/2019/11/10/%E5%AE%9A%E5%88%B6%E5%8C%96%E5%86%85%E5%B5%8CTomcat%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>SpringBoot内嵌Tomcat无KeepAlive参数，需在服务端自己配置。</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814151400.png" alt="image-20200814151400454"></p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814152817.png" alt="image-20200814152817878"></p>
<p>当我们的SpringBoot启动之后，会将我们的server.Tomcat的参数加载到protocol内。我们只需定义WebServerConfiguration，他会将我们之前组装出来的参数在传到对应的ConfigurableWebServerFactory内，然后我们可以将相应的参数customize出来，最后再有一次机会可以修改对应的参数。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>连接学校内网服务器</title>
    <url>/2020/01/18/%E8%BF%9E%E6%8E%A5%E5%AD%A6%E6%A0%A1%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="方式1：ssh反向代理"><a href="#方式1：ssh反向代理" class="headerlink" title="方式1：ssh反向代理"></a>方式1：ssh反向代理</h1><p>ssh做反向代理，可以实现无论在什么位置都能访问到学校内网服务器</p>
<p><strong>适用场景：</strong></p>
<p>主机B不能直接访问主机A</p>
<p>主机A能直接访问主机B</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814211301.png" alt="image-20200814211301392"></p>
<p>ip是我瞎编的，以防攻击</p>
<p>SSH参数介绍（区分大小写）</p>
<p>  -f：后台执行ssh指令</p>
<p>  -C：允许压缩数据</p>
<p>  -N：不执行远程指令</p>
<p>  -R：将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口</p>
<p>  -L：将本地机(客户机)的某个端口转发到远端指定机器的指定端口</p>
<p>  -p：指定远程主机的端口</p>
<h3 id="学校内网服务器操作："><a href="#学校内网服务器操作：" class="headerlink" title="学校内网服务器操作："></a>学校内网服务器操作：</h3><p># ssh -fNR 远程端口:localhost:本地端口 远程用户@远程ip</p>
<p><code>ssh -NfR 2345:localhost:22 root@12.12.12.12 -p 22</code></p>
<p>之后会要求你输入公网阿里云服务器的密码，输入正确后，可以通过：ps -ef | grep ssh 来查看进程情况，成功显示说明这一步成功。</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814211331.png" alt="img"></p>
<p>第一步完成后，就可以在任意位置访问公网阿里云服务器进行一下操作访问学校内网服务器了。</p>
<h3 id="公网阿里云服务器操作："><a href="#公网阿里云服务器操作：" class="headerlink" title="公网阿里云服务器操作："></a>公网阿里云服务器操作：</h3><p>ssh 内网用户名@localhost -p 本地端口号</p>
<p><code>ssh manli@localhost -p2345</code></p>
<p>之后要求输入相应的用户名的密码，正确输入后，便可以访问学校内网服务器了。</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814211355.png" alt="img"></p>
<p>但是这样很不稳定，非常不稳定，总是会断掉，尽管进程在，但是连接已经断掉，所以这个时候就可以用到autossh来自动重新连接。</p>
<h3 id="autossh保证连接稳定："><a href="#autossh保证连接稳定：" class="headerlink" title="autossh保证连接稳定："></a>autossh保证连接稳定：</h3><p>autossh与ssh的区别就在于<strong>在学校内网操作的时候</strong>，命令变成：</p>
<p><code>autossh -M 2346 -NfR 2345:localhost:22 root@12.12.12.12 -p 22</code></p>
<p>-M参数指定一个端口，这个端口是公网机器用来接收内网机器的信息，如果隧道不正常而返回给内网机器让他实现重新连接。</p>
<p>（如果没有安装autossh，在ubuntu下，用apy-get install autossh进行安装）</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814211439.png" alt="img"></p>
<p>这样就能稳定的从任何地方访问学校内网服务器了，开心。</p>
<h4 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h4><p>在学校内网操作的时候，因为我弄了太多，导致端口冲突，出现了下面这个问题：</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814211455.png" alt="img"></p>
<p>解决方法如下：</p>
<p>1）首先查看进程：<code>ps -ef | grep ssh</code></p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200814211511.png" alt="img"></p>
<p>2）发现有很多2345端口的进程，所以才会出现端口连接错误，所以用命令杀死进程，再做操作：<code>kill -9 进程ID</code></p>
<p>如果不是超级用户，就用：<code>sudo kill -9 进程ID</code>  来操作</p>
<h1 id="方式2：easyconnect"><a href="#方式2：easyconnect" class="headerlink" title="方式2：easyconnect"></a>方式2：easyconnect</h1><p>1.通过easyconnect进入学校内网</p>
<p>2.通过ssh命令直接连接学校内网服务器即可</p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter压测工具</title>
    <url>/2019/12/16/jmeter%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h1><p>一般在项目完成之后，上线之前，都需要进行有一步专门的测试动作，即性能压测，依靠性能压测，可发现很多瓶颈。这时便会用到我们的jmeter性能压测工作。</p>
<p>jmeter是apache研发的基于Java的性能压测工具，是一个集成了各种各样接口的客户端。jmeter性能压测必须具备的4个东西</p>
<ul>
<li>线程组：首先我们需要创建一个线程组，用来组装jmeter发送请求的线程池。</li>
<li>Http请求：压测接口</li>
<li>查看结果树：能看到成功数，失败数，响应值</li>
<li>聚合报告：可以看到平均数，中位数，90线，<strong>95线</strong>，99线，<strong>TPS</strong>，收发包数量，其中95线和TPS是重点</li>
</ul>
<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183610.png" alt="image-20200813210812279"></p>
<p>这表示在10s内启动100个线程，每个线程会进行10次http请求</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183610.png" alt="image-20200813210959686"></p>
<p>一个线程组里可以有结果树，聚合报告和Http请求。</p>
<h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><p>我们可以使用<code>vi /etc/hosts</code>设置本地的DNS解析，自定义域名到云端ip。</p>
<p>在线程组的Http请求中：</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183610.png" alt="image-20200813211117714"></p>
<p>在高级中，客户端实现我们选择Java，因为我们需要使用KeepAlive，Http的KeepAlive可以保证其是长连接的，不使用短连接，因为若我们的压侧接口的大部分时候性能都耗费在建立连接关闭连接上面，那这个性能压测我们是不能接受的，我们要压测的其实是接口的响应时耗，因此我们选择长连接将对应的网络连接关闭的消耗降低到最少。</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183610.png" alt="image-20200813211503625"></p>
<p>压测一般都是从小到大，循序渐进的</p>
<h2 id="结果树"><a href="#结果树" class="headerlink" title="结果树"></a>结果树</h2><p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183610.png" alt="image-20200813214534941"></p>
<h2 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h2><p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183610.png" alt="image-20200813214618295"></p>
<p>90线表示百分之90的请求是落在多少ms之内返回，即另外的百分之5的请求是大于这个数值的</p>
<p>95线表示百分之95的请求是落在多少ms之内返回</p>
<p>99线表示百分之99的请求是落在多少ms之内返回</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p><code>pstree -p jar线程 | wc -l</code>查看该进程对应的线程数</p>
<p>一般来说，Tomcat服务器默认会维护30个左右的线程池的线程数量(其中有点是springboot开的线程)</p>
<p><code>top -H</code>可以查看机器的性能数量</p>
<p><img src="https://gitee.com/destiny-z/blogImg/raw/master/img/20200816183612.png" alt="image-20200813221813013"></p>
<p>其中<code>us</code>表示用户态下执行的CPU占有率，<code>sy</code>表示在内核态下执行的CPU占有率，这两个占用率加在一起不能超过百分之100。右上角<code>load average</code>分别表示在最近的1min，5min，15min对应的CPU load数量，越低越好</p>
]]></content>
      <categories>
        <category>压测</category>
      </categories>
      <tags>
        <tag>压测</tag>
      </tags>
  </entry>
</search>
