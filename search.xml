<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线程池</title>
    <url>/2020/01/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，<br>还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="实现Runnable接口和Callable接口的区别"><a href="#实现Runnable接口和Callable接口的区别" class="headerlink" title="实现Runnable接口和Callable接口的区别"></a>实现Runnable接口和Callable接口的区别</h4><p><code>Runnable</code>自Java 1.0以来一直存在，但<code>Callable</code>仅在Java 1.5中引入,<br>目的就是为了来处理<code>Runnable</code>不支持的用例。<br><code>Runnable</code> 接口不会返回结果或抛出检查异常，<br>但是<code>Callable</code> 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <code>Runnable</code> 接口，<br>这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。<br>（<code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<h4 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h4><ul>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，<br>通过这个 <code>Future</code> 对象可以判断任务是否执行成功，</strong><br>并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，<br>而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，<br>而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<p><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。<br><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</p>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><strong>方式二：通过Executor 框架的工具类Executors来实现</strong> 我们可以创建三种类型的ThreadPoolExecutor：</p>
<ul>
<li>FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li>SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li>CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<h4 id="ThreadPoolExecutor-类分析"><a href="#ThreadPoolExecutor-类分析" class="headerlink" title="ThreadPoolExecutor 类分析"></a>ThreadPoolExecutor 类分析</h4><p><code>ThreadPoolExecutor</code>类中提供的四个构造方法。我们来看最长的那个，<br>其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">    this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">    this.workQueue &#x3D; workQueue;</span><br><span class="line">    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory &#x3D; threadFactory;</span><br><span class="line">    this.handler &#x3D; handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadPoolExecutor</code><strong>构造函数重要参数分析</strong></p>
<p><code>ThreadPoolExecutor</code><strong>3 个最重要的参数</strong>：</p>
<ul>
<li><code>corePoolSize</code> : 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><code>maximumPoolSize</code> : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><code>workQueue</code>: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ul>
<li><code>keepAliveTime</code>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，<br>而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><code>threadFactory</code> :<code>executor</code> 创建新线程的时候会用到。</li>
<li><code>handler</code> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<p><code>ThreadPoolExecutor</code> <strong>饱和策略</strong><br><code>ThreadPoolExecutor</code> <strong>饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：<strong>调用执行自己的线程运行任务</strong>。您不会任务请求。<br>但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。<br>如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>： 不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>： 此策略将丢弃最早的未处理的任务请求。<br>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，<br>当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。<br>在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。<br>对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。<br>（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</li>
</ul>
]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发基础</title>
    <url>/2020/02/23/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Java并发基础"><a href="#Java并发基础" class="headerlink" title="Java并发基础"></a>Java并发基础</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h4><p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的</strong>。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p><strong>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</strong><a id="more"></a></p>
<h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h4><p>线程与进程相似，<strong>但线程是一个比进程更小的执行单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h4 id="请简要描述线程与进程的关系-区别及优缺点"><a href="#请简要描述线程与进程的关系-区别及优缺点" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点"></a>请简要描述线程与进程的关系,区别及优缺点</h4><!--![](D:\github\source\_posts\P}$JF5JJ7`A1)]~HZF$PAJ2.png)-->

<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong> (JDK1.8 之后的<strong>元空间</strong>)资源，但是每个线程有自己的*<em>程序计数器*</em>、<strong>虚拟机栈 和 **本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上<strong>各进程是独立的</strong>，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h4><p>程序计数器主要有下面两个作用：</p>
<ol>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
</li>
<li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
</li>
</ol>
<h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h4><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>​       为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<p><strong>堆和方法区</strong>是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h4 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h4><ul>
<li><strong>并发：</strong> 同一时间段，多个任务<strong>都在</strong>执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务<strong>同时</strong>执行。</li>
</ul>
<h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h4 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h4><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、上下文切换、死锁</strong>还有受限于硬件和软件的资源闲置问题。</p>
<h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h4 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>当线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，此时这两个线程就会互相等待而进入死锁状态。</p>
<!-- ![](D:\github\source\_posts\QGB]6)$MU~~0@WM_@(926L3.png) -->


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    private static Object resource1 &#x3D; new Object();&#x2F;&#x2F;资源 1</span><br><span class="line">    private static Object resource2 &#x3D; new Object();&#x2F;&#x2F;资源 2</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;waiting get resource2&quot;);</span><br><span class="line">                synchronized (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程 1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;waiting get resource1&quot;);</span><br><span class="line">                synchronized (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程 2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程 1get resource1</span><br><span class="line">线程 2get resource2</span><br><span class="line">线程 1waiting get resource2</span><br><span class="line">线程 2waiting get resource1</span><br></pre></td></tr></table></figure>

<p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    synchronized (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;get resource1&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);</span><br><span class="line">        synchronized (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot;get resource2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;线程 2&quot;).start();</span><br></pre></td></tr></table></figure>



<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p>
<!-- ![](D:\github\source\_posts\OS16]DR4{Q}PMZJMAIOLI6X.png) -->


<p><strong>新建（New）</strong>：创建后尚未启动的线程处于这种状态；<br><strong>运行（Runnable）</strong>：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间；<br><strong>无限期等待（Waiting）</strong>：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其它线程显式地唤醒；以下三种方法会让线程进入无限期等待状态：<br>没有设置 TimeOut 参数的 Object.wait()；<br>没有设置 TimeOut 参数的 Thread.join()；<br>LockSupport.park()。<br><strong>限期等待（Timed Waiting）</strong>：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒；以下方法会让线程进入限期等待状态：<br>Thread.sleep()；<br>设置了 TimeOut 参数的 Object.wait()；<br>设置了 TimeOut 参数的 Thread.join()；<br>LockSupport.parkNanos()；<br>LockSupport.parkUntil()。<br><strong>阻塞（Blocked）</strong>：线程被阻塞了，「阻塞状态」和「等待状态」的区别是：「阻塞状态」在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发送。在程序等待进入同步区域时，线程将进入这种状态；<br><strong>结束（Terminated）</strong>：线程已经结束执行。</p>
<h4 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点?"></a>sleep() 方法和 wait() 方法区别和共同点?</h4><ul>
<li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
]]></content>
      <categories>
        <category>Java JUC</category>
      </categories>
      <tags>
        <tag>Java JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/10/11/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表之链表中倒数第k个节点"><a href="#链表之链表中倒数第k个节点" class="headerlink" title="链表之链表中倒数第k个节点"></a>链表之链表中倒数第k个节点</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><ul>
<li>第一时间想到的解法：<ul>
<li>先遍历统计链表长度，记为 n ；</li>
<li>设置一个指针走 (n-k) 步，即可找到链表倒数第 k 个节点。</li>
</ul>
</li>
<li>使用双指针则可以不用统计链表长度。<ul>
<li>初始化： 快指针 <code>fast</code> 、慢指针 <code>slow</code> ，双指针都指向头节点 <code>head</code>​ 。</li>
<li>构建双指针距离： 快指针 <code>fast</code> 先向前走 k 步（结束后，双指针 <code>fast</code> 和 <code>slow</code> 间相距 k 步）。</li>
<li>双指针共同移动： 循环中，双指针 <code>fast</code> 和 <code>slow</code> 每轮都向前走一步，直至 <code>fast</code> 走过链表 尾节点 时跳出（跳出后， <code>slow</code> 与尾节点距离为 k−1，即 <code>slow</code> 指向倒数第 k 个节点）。</li>
<li>返回值： 返回 <code>slow</code> 即可。</li>
</ul>
</li>
</ul>
<p><strong>下面采用双指针的方法进行求解</strong></p>
<p><strong>双指针复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为链表长度；总体看， <code>fast</code> 走了 N 步， <code>slow</code> 走了 (N-k) 步。</li>
<li>空间复杂度 O(1) ： 双指针 <code>fast</code> , <code>slow</code> 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode getKthFromEnd(ListNode head, int k) &#123;</span><br><span class="line">        ListNode fast &#x3D; head, slow &#x3D; head;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">            if (fast &#x3D;&#x3D; null) return null;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast!&#x3D;null)&#123;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表之两个链表的第一个公共节点"><a href="#链表之两个链表的第一个公共节点" class="headerlink" title="链表之两个链表的第一个公共节点"></a>链表之两个链表的第一个公共节点</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共节点。</p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们使用两个指针 <code>ptr1</code>，<code>ptr2</code> 分别指向两个链表 <code>headA</code>，<code>headB</code> 的头结点，<br>然后同时分别逐结点遍历，当 <code>ptr1</code> 到达链表 <code>headA</code> 的末尾时，<br>重新定位到链表 <code>headB</code> 的头结点；当 <code>ptr2</code> 到达链表 <code>headB</code> 的末尾时，重新定位到链表 <code>headA</code> 的头结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val &#x3D; x;</span><br><span class="line"> *         next &#x3D; null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode ptr1 &#x3D; headA, ptr2 &#x3D; headB;</span><br><span class="line">        while(ptr1 !&#x3D; ptr2)&#123;</span><br><span class="line">            ptr1 &#x3D; ptr1 &#x3D;&#x3D; null?headB:ptr1.next;</span><br><span class="line">            ptr2 &#x3D; ptr2 &#x3D;&#x3D; null?headA:ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表之反转链表"><a href="#链表之反转链表" class="headerlink" title="链表之反转链表"></a>链表之反转链表</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>双指针求解</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre &#x3D; null, preOfPre &#x3D; null, cur &#x3D; head;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            pre &#x3D; cur;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">            pre.next &#x3D; preOfPre;</span><br><span class="line">            preOfPre &#x3D; pre;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表之删除链表的节点"><a href="#链表之删除链表的节点" class="headerlink" title="链表之删除链表的节点"></a>链表之删除链表的节点</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>引入哨兵节点prior，减少情况讨论</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteNode(ListNode head, int val) &#123;</span><br><span class="line">        ListNode prior &#x3D; new ListNode(-1);</span><br><span class="line">        prior.next &#x3D; head;</span><br><span class="line">        ListNode ptr &#x3D; prior;</span><br><span class="line">        while(ptr.next!&#x3D;null &amp;&amp; ptr.next.val !&#x3D; val)&#123;</span><br><span class="line">            ptr &#x3D; ptr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ptr.next !&#x3D; null)&#123;</span><br><span class="line">            ptr.next &#x3D; ptr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return prior.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表之复杂链表的复制"><a href="#链表之复杂链表的复制" class="headerlink" title="链表之复杂链表的复制"></a>链表之复杂链表的复制</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，<br>每个节点除了有一个 <code>next</code> 指针指向下一个节点，<br>还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">&#x2F;&#x2F; Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    public Node(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.next &#x3D; null;</span><br><span class="line">        this.random &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null) return null;</span><br><span class="line">        Node ptr &#x3D; head;</span><br><span class="line">        while(ptr !&#x3D; null)&#123;</span><br><span class="line">            Node tmp &#x3D; new Node(ptr.val);</span><br><span class="line">            tmp.next &#x3D; ptr.next;</span><br><span class="line">            ptr.next &#x3D; tmp;</span><br><span class="line">            ptr &#x3D; ptr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr &#x3D; head;</span><br><span class="line">        while(ptr!&#x3D;null)&#123;</span><br><span class="line">            if(ptr.random!&#x3D;null)&#123;</span><br><span class="line">                ptr.next.random &#x3D; ptr.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ptr &#x3D; ptr.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr &#x3D; head;</span><br><span class="line">        Node res &#x3D; ptr.next;</span><br><span class="line">        while(ptr!&#x3D;null)&#123;</span><br><span class="line">            Node tmp &#x3D; ptr.next;</span><br><span class="line">            ptr.next &#x3D; ptr.next.next;</span><br><span class="line">            if(tmp.next!&#x3D;null)&#123;</span><br><span class="line">                tmp.next &#x3D; tmp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr &#x3D; ptr.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p>
<ul>
<li>常见的 DFS ： 先序遍历、中序遍历、后序遍历；</li>
<li>常见的 BFS ： 层序遍历（即按层遍历）。</li>
</ul>
<h3 id="二叉树之二叉树的深度"><a href="#二叉树之二叉树的深度" class="headerlink" title="二叉树之二叉树的深度"></a>二叉树之二叉树的深度</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h4 id="Java非递归版本-层次遍历（BFS）"><a href="#Java非递归版本-层次遍历（BFS）" class="headerlink" title="Java非递归版本-层次遍历（BFS）"></a>Java非递归版本-层次遍历（BFS）</h4><ul>
<li>树的层序遍历 / 广度优先搜索往往利用<strong>队列</strong>实现。</li>
<li>关键点： 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li><strong>特例处理</strong>： 当 <code>root</code>​ 为空，直接返回 深度 0 。</li>
<li><strong>初始化</strong>： 队列 <code>queue</code> （加入根节点 <code>root</code> ），计数器 <code>res = 0</code>。</li>
<li><strong>循环遍历</strong>： 当 <code>queue</code> 为空时跳出。<ul>
<li>1 初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点；</li>
<li>2 遍历队列： 遍历 <code>queue</code> 中的各节点 <code>node</code> ，并将其左子节点和右子节点加入 tmp；</li>
<li>3 更新队列： 执行 <code>queue = tmp</code> ，将下一层节点赋值给 <code>queue</code>；</li>
<li>4 统计层数： 执行 <code>res += 1</code> ，代表层数加 1；</li>
</ul>
</li>
<li><strong>返回值</strong>： 返回 <code>res</code> 即可。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 <code>queue</code> 同时存储 N/2 个节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        List&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            tmp &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">            for(TreeNode node : queue) &#123;</span><br><span class="line">                if(node.left !&#x3D; null) tmp.add(node.left);</span><br><span class="line">                if(node.right !&#x3D; null) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue &#x3D; tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java递归版本-后序遍历"><a href="#Java递归版本-后序遍历" class="headerlink" title="Java递归版本-后序遍历"></a>Java递归版本-后序遍历</h4><ul>
<li>树的后序遍历 / 深度优先搜索往往利用<strong>递归</strong>或<strong>栈</strong>实现，本文使用递归实现。</li>
<li><strong>关键点</strong>： 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong>等于<strong>左子树的深度</strong>与<strong>右子树的深度</strong>中的<strong>最大值</strong>+1。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li>终止条件： 当 <code>root</code>​ 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li>递推工作： 本质上是对树做后序遍历。<ul>
<li>1 计算节点 <code>root​</code> 的 左子树的深度 ，即调用 <code>maxDepth(root.left)</code>；</li>
<li>2 计算节点 <code>root</code>​ 的 右子树的深度 ，即调用 <code>maxDepth(root.right)</code>；</li>
</ul>
</li>
<li>返回值： 返回 此树的深度 ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int leftDepth &#x3D; maxDepth(root.left);</span><br><span class="line">        int rightDepth &#x3D; maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之对称的二叉树"><a href="#二叉树之对称的二叉树" class="headerlink" title="二叉树之对称的二叉树"></a>二叉树之对称的二叉树</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：<ul>
<li>L.val=R.val ：即此两对称节点值相等。</li>
<li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>
</ul>
<p><strong>算法流程</strong><br><code>isSymmetric(root)</code> ：</p>
<ul>
<li>特例处理： 若根节点 <code>root</code> 为空，则直接返回 true 。</li>
<li>返回值： 即 <code>recu(root.left, root.right)</code> ;</li>
</ul>
<p><code>recu(L, R)</code></p>
<ul>
<li>终止条件：<ul>
<li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；<br>当节点 L 值 != 节点 R 值： 此树不对称，因此返回 false ；</li>
</ul>
</li>
<li>递推工作：<ul>
<li>判断两节点 L.left 和 R.right 是否对称，即 <code>recu(L.left, R.right)</code> ；</li>
<li>判断两节点 L.right 和 R.left 是否对称，即 <code>recu(L.right, R.left)</code> ；</li>
</ul>
</li>
<li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li>
</ul>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 <code>recu()</code> 可以判断一对节点是否对称，因此最多调用 N/2 次 <code>recu()</code> 方法。</li>
<li>空间复杂度 O(N) ： 最差情况下，二叉树退化为链表，系统使用 O(N) 大小的栈空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return true;</span><br><span class="line">        return recu(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean recu(TreeNode root1, TreeNode root2)&#123;</span><br><span class="line">        if(root1 &#x3D;&#x3D; null &amp;&amp; root2 &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null) return false;</span><br><span class="line">        if(root1.val !&#x3D; root2.val) return false;</span><br><span class="line">        return recu(root1.left, root2.right) &amp;&amp; recu(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之平衡二叉树"><a href="#二叉树之平衡二叉树" class="headerlink" title="二叉树之平衡二叉树"></a>二叉树之平衡二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p><strong>二叉树的深度的扩展</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private boolean res &#x3D; true;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return true;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private int dfs(TreeNode node)&#123;</span><br><span class="line">        if(res &#x3D;&#x3D; false) return -1;</span><br><span class="line">        if(node &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int leftDepth &#x3D; dfs(node.left);</span><br><span class="line">        int rightDepth &#x3D; dfs(node.right);</span><br><span class="line">        if(Math.abs(leftDepth - rightDepth) &gt; 1)&#123;</span><br><span class="line">            res &#x3D; false;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之重建二叉树"><a href="#二叉树之重建二叉树" class="headerlink" title="二叉树之重建二叉树"></a>二叉树之重建二叉树</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        System.out.println(preorder);</span><br><span class="line">        if (preorder.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; preorder.length;</span><br><span class="line">        int rootVal &#x3D; preorder[0];</span><br><span class="line">        TreeNode ptr &#x3D; new TreeNode(rootVal);</span><br><span class="line">        int rootValIndex &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (rootVal &#x3D;&#x3D; inorder[i])&#123;</span><br><span class="line">                rootValIndex &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] preorder1 &#x3D; Arrays.copyOfRange(preorder, 1, 1 + rootValIndex);</span><br><span class="line">        int[] preorder2 &#x3D; Arrays.copyOfRange(preorder, 1 + rootValIndex, len);</span><br><span class="line">        int[] inorder1 &#x3D; Arrays.copyOfRange(inorder, 0, rootValIndex);</span><br><span class="line">        int[] inorder2 &#x3D; Arrays.copyOfRange(inorder, 1+rootValIndex, len);</span><br><span class="line">        ptr.left &#x3D; buildTree(preorder1, inorder1);</span><br><span class="line">        ptr.right &#x3D; buildTree(preorder2, inorder2);</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>改进，引入哈希表，以空间换时间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     &#x2F;&#x2F; 改进，特征输入用例的考虑，如输入数组为空， 输入数组长度不一</span><br><span class="line">     &#x2F;&#x2F;加入哈希表，以空间换时间</span><br><span class="line">    private Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private int[] preorder;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if (preorder &#x3D;&#x3D; null || preorder.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int len1 &#x3D; preorder.length;</span><br><span class="line">        int len2 &#x3D; inorder.length;</span><br><span class="line">        if (len1 !&#x3D; len2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        this.preorder &#x3D; preorder;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len1; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return recu(0, len1-1, 0, len2-1);</span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode recu(int preL, int preR, int inL, int inR) &#123;</span><br><span class="line">        if (preL &gt; preR)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode ptr &#x3D;  new TreeNode(preorder[preL]);</span><br><span class="line">       </span><br><span class="line">        int indexIn &#x3D; map.get(preorder[preL]); </span><br><span class="line">        ptr.left &#x3D; recu(preL+1, preL + indexIn - inL, inL, indexIn - 1);</span><br><span class="line">        ptr.right &#x3D; recu(preL + indexIn - inL + 1, preR, indexIn + 1, inR);</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之-之字形打印二叉树"><a href="#二叉树之-之字形打印二叉树" class="headerlink" title="二叉树之 之字形打印二叉树"></a>二叉树之 之字形打印二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>求解：层次遍历 + 双端队列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; deque &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        boolean pos &#x3D; true;</span><br><span class="line">        while(!deque.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            int length &#x3D; deque.size();</span><br><span class="line">            if(pos &#x3D;&#x3D; true)&#123;</span><br><span class="line">                for(int i &#x3D; 0;i &lt; length; i++)&#123;</span><br><span class="line">                    TreeNode poped &#x3D; deque.pollFirst();</span><br><span class="line">                    tmp.add(poped.val);</span><br><span class="line">                    if(poped.left!&#x3D;null) deque.addLast(poped.left);</span><br><span class="line">                    if(poped.right!&#x3D;null) deque.addLast(poped.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for(int i &#x3D; 0;i &lt; length; i++)&#123;</span><br><span class="line">                    TreeNode poped &#x3D; deque.pollLast();</span><br><span class="line">                    tmp.add(poped.val);</span><br><span class="line">                    if(poped.right!&#x3D;null) deque.addFirst(poped.right);</span><br><span class="line">                    if(poped.left!&#x3D;null) deque.addFirst(poped.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            pos &#x3D; !pos;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之树的子结构"><a href="#二叉树之树的子结构" class="headerlink" title="二叉树之树的子结构"></a>二叉树之树的子结构</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值<br><strong>非递归</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;</span><br><span class="line">        if(A &#x3D;&#x3D; null || B &#x3D;&#x3D; null) return false;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        TreeNode ptr &#x3D; A;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line">        while(!stack.isEmpty() || ptr !&#x3D; null)&#123;</span><br><span class="line">            if (ptr !&#x3D; null) res &#x3D; isSub(ptr, B);</span><br><span class="line">            if(res &#x3D;&#x3D; true) &#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">            if(ptr!&#x3D;null)&#123;</span><br><span class="line">                stack.push(ptr);</span><br><span class="line">                ptr &#x3D; ptr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                TreeNode poped &#x3D; stack.pop();</span><br><span class="line">                ptr &#x3D; poped.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isSub(TreeNode ptr, TreeNode B)&#123;</span><br><span class="line">        if(B &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(ptr &#x3D;&#x3D; null || ptr.val !&#x3D; B.val) return false;</span><br><span class="line">        else return isSub(ptr.left, B.left) &amp;&amp; isSub(ptr.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;</span><br><span class="line">        if(A &#x3D;&#x3D; null || B &#x3D;&#x3D; null) return false;</span><br><span class="line">        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isSub(TreeNode ptr, TreeNode B)&#123;</span><br><span class="line">        if(B &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(ptr &#x3D;&#x3D; null || ptr.val !&#x3D; B.val) return false;</span><br><span class="line">        else return isSub(ptr.left, B.left) &amp;&amp; isSub(ptr.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之二叉树中和为某一值的路径"><a href="#二叉树之二叉树中和为某一值的路径" class="headerlink" title="二叉树之二叉树中和为某一值的路径"></a>二叉树之二叉树中和为某一值的路径</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    Stack&lt;Integer&gt; path &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        </span><br><span class="line">        ptr_Search(root, sum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ptr_Search(TreeNode ptr, int sum) &#123;</span><br><span class="line">        if (ptr &#x3D;&#x3D; null) return;</span><br><span class="line">        path.push(ptr.val);</span><br><span class="line">        sum -&#x3D; ptr.val;</span><br><span class="line">        if (sum &#x3D;&#x3D; 0 &amp;&amp; ptr.left &#x3D;&#x3D; null &amp;&amp; ptr.right &#x3D;&#x3D; null)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            path.pop();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr_Search(ptr.left, sum);</span><br><span class="line">        ptr_Search(ptr.right, sum);</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之二叉树的最近公共祖先"><a href="#二叉树之二叉树的最近公共祖先" class="headerlink" title="二叉树之二叉树的最近公共祖先"></a>二叉树之二叉树的最近公共祖先</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    private TreeNode res &#x3D; null;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        pre_search(root, p, q);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private int pre_search(TreeNode root, TreeNode p, TreeNode q)&#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        if(res !&#x3D; null) return 0;</span><br><span class="line">        int left &#x3D; pre_search(root.left, p, q);</span><br><span class="line">        int right &#x3D; pre_search(root.right, p, q);</span><br><span class="line">        int tmp &#x3D; 0;</span><br><span class="line">        if(root &#x3D;&#x3D; p || root &#x3D;&#x3D; q)&#123;</span><br><span class="line">            tmp &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum &#x3D; tmp + left + right;</span><br><span class="line">        if(sum &gt;&#x3D; 2)&#123;</span><br><span class="line">            res &#x3D; root;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之二叉搜索树的第k大节点"><a href="#二叉树之二叉搜索树的第k大节点" class="headerlink" title="二叉树之二叉搜索树的第k大节点"></a>二叉树之二叉搜索树的第k大节点</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int kthLargest(TreeNode root, int k) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        TreeNode ptr &#x3D; root, poped;</span><br><span class="line">        while(!stack.isEmpty() || ptr !&#x3D; null)&#123;</span><br><span class="line">            while(ptr !&#x3D; null)&#123;</span><br><span class="line">                stack.add(ptr);</span><br><span class="line">                ptr &#x3D; ptr.right;</span><br><span class="line">            &#125;</span><br><span class="line">            poped &#x3D; stack.pop();</span><br><span class="line">            k -&#x3D; 1;</span><br><span class="line">            if(k &#x3D;&#x3D; 0) return poped.val;</span><br><span class="line">            ptr &#x3D; poped.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
