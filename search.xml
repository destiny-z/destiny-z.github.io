<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java并发基础</title>
    <url>/2020/01/20/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Java并发基础"><a href="#Java并发基础" class="headerlink" title="Java并发基础"></a>Java并发基础</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h4 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h4><p><strong>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的</strong>。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p><strong>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</strong><a id="more"></a></p>
<h4 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h4><p>线程与进程相似，<strong>但线程是一个比进程更小的执行单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h4 id="请简要描述线程与进程的关系-区别及优缺点"><a href="#请简要描述线程与进程的关系-区别及优缺点" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点"></a>请简要描述线程与进程的关系,区别及优缺点</h4><!--![](D:\github\source\_posts\P}$JF5JJ7`A1)]~HZF$PAJ2.png)-->

<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong> (JDK1.8 之后的<strong>元空间</strong>)资源，但是每个线程有自己的*<em>程序计数器*</em>、<strong>虚拟机栈 和 **本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程</strong> 是 <strong>进程</strong> 划分成的更小的运行单位。线程和进程最大的不同在于基本上<strong>各进程是独立的</strong>，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h4><p>程序计数器主要有下面两个作用：</p>
<ol>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
</li>
<li><p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<p>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
</li>
</ol>
<h4 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h4><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>​       为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<p><strong>堆和方法区</strong>是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h4 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h4><ul>
<li><strong>并发：</strong> 同一时间段，多个任务<strong>都在</strong>执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务<strong>同时</strong>执行。</li>
</ul>
<h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h4 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h4><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、上下文切换、死锁</strong>还有受限于硬件和软件的资源闲置问题。</p>
<h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h4 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h4><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="D:%5Cgithub%5Csource_posts%5CQGB%5D6" alt="">)$MU~~0@WM_@(926L3.png)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    private static Object resource1 &#x3D; new Object();&#x2F;&#x2F;资源 1</span><br><span class="line">    private static Object resource2 &#x3D; new Object();&#x2F;&#x2F;资源 2</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;waiting get resource2&quot;);</span><br><span class="line">                synchronized (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程 1&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;get resource2&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;waiting get resource1&quot;);</span><br><span class="line">                synchronized (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;get resource1&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程 2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程 1get resource1</span><br><span class="line">线程 2get resource2</span><br><span class="line">线程 1waiting get resource2</span><br><span class="line">线程 2waiting get resource1</span><br></pre></td></tr></table></figure>

<p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    synchronized (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;get resource1&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + &quot;waiting get resource2&quot;);</span><br><span class="line">        synchronized (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + &quot;get resource2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &quot;线程 2&quot;).start();</span><br></pre></td></tr></table></figure>



<h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态?"></a>线程的生命周期和状态?</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态</p>
<p><img src="D:%5Cgithub%5Csource_posts%5COS16%5DDR4%7BQ%7DPMZJMAIOLI6X.png" alt=""></p>
<p><strong>新建（New）</strong>：创建后尚未启动的线程处于这种状态；<br><strong>运行（Runnable）</strong>：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间；<br><strong>无限期等待（Waiting）</strong>：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其它线程显式地唤醒；以下三种方法会让线程进入无限期等待状态：<br>没有设置 TimeOut 参数的 Object.wait()；<br>没有设置 TimeOut 参数的 Thread.join()；<br>LockSupport.park()。<br><strong>限期等待（Timed Waiting）</strong>：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒；以下方法会让线程进入限期等待状态：<br>Thread.sleep()；<br>设置了 TimeOut 参数的 Object.wait()；<br>设置了 TimeOut 参数的 Thread.join()；<br>LockSupport.parkNanos()；<br>LockSupport.parkUntil()。<br><strong>阻塞（Blocked）</strong>：线程被阻塞了，「阻塞状态」和「等待状态」的区别是：「阻塞状态」在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发送。在程序等待进入同步区域时，线程将进入这种状态；<br><strong>结束（Terminated）</strong>：线程已经结束执行。</p>
<h4 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点?"></a>sleep() 方法和 wait() 方法区别和共同点?</h4><ul>
<li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li>
</ul>
<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
]]></content>
      <categories>
        <category>Java JUC</category>
      </categories>
      <tags>
        <tag>Java JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/04/23/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2019/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p>
<ul>
<li>常见的 DFS ： 先序遍历、中序遍历、后序遍历；</li>
<li>常见的 BFS ： 层序遍历（即按层遍历）。</li>
</ul>
<h3 id="二叉树之二叉树的深度"><a href="#二叉树之二叉树的深度" class="headerlink" title="二叉树之二叉树的深度"></a>二叉树之二叉树的深度</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h4 id="Java非递归版本-层次遍历（BFS）"><a href="#Java非递归版本-层次遍历（BFS）" class="headerlink" title="Java非递归版本-层次遍历（BFS）"></a>Java非递归版本-层次遍历（BFS）</h4><ul>
<li>树的层序遍历 / 广度优先搜索往往利用<strong>队列</strong>实现。</li>
<li>关键点： 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li><strong>特例处理</strong>： 当 <code>root</code>​ 为空，直接返回 深度 0 。</li>
<li><strong>初始化</strong>： 队列 <code>queue</code> （加入根节点 <code>root</code> ），计数器 <code>res = 0</code>。</li>
<li><strong>循环遍历</strong>： 当 <code>queue</code> 为空时跳出。<ul>
<li>1 初始化一个空列表 <code>tmp</code> ，用于临时存储下一层节点；</li>
<li>2 遍历队列： 遍历 <code>queue</code> 中的各节点 <code>node</code> ，并将其左子节点和右子节点加入 tmp；</li>
<li>3 更新队列： 执行 <code>queue = tmp</code> ，将下一层节点赋值给 <code>queue</code>；</li>
<li>4 统计层数： 执行 <code>res += 1</code> ，代表层数加 1；</li>
</ul>
</li>
<li><strong>返回值</strong>： 返回 <code>res</code> 即可。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 <code>queue</code> 同时存储 N/2 个节点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        List&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;() &#123;&#123; add(root); &#125;&#125;, tmp;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            tmp &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">            for(TreeNode node : queue) &#123;</span><br><span class="line">                if(node.left !&#x3D; null) tmp.add(node.left);</span><br><span class="line">                if(node.right !&#x3D; null) tmp.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            queue &#x3D; tmp;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java递归版本-后序遍历"><a href="#Java递归版本-后序遍历" class="headerlink" title="Java递归版本-后序遍历"></a>Java递归版本-后序遍历</h4><ul>
<li>树的后序遍历 / 深度优先搜索往往利用<strong>递归</strong>或<strong>栈</strong>实现，本文使用递归实现。</li>
<li><strong>关键点</strong>： 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong>等于<strong>左子树的深度</strong>与<strong>右子树的深度</strong>中的<strong>最大值</strong>+1。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ol>
<li>终止条件： 当 <code>root</code>​ 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li>递推工作： 本质上是对树做后序遍历。<ul>
<li>1 计算节点 <code>root​</code> 的 左子树的深度 ，即调用 <code>maxDepth(root.left)</code>；</li>
<li>2 计算节点 <code>root</code>​ 的 右子树的深度 ，即调用 <code>maxDepth(root.right)</code>；</li>
</ul>
</li>
<li>返回值： 返回 此树的深度 ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int leftDepth &#x3D; maxDepth(root.left);</span><br><span class="line">        int rightDepth &#x3D; maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树之对称的二叉树"><a href="#二叉树之对称的二叉树" class="headerlink" title="二叉树之对称的二叉树"></a>二叉树之对称的二叉树</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：<ul>
<li>L.val=R.val ：即此两对称节点值相等。</li>
<li>L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>
</ul>
<p><strong>算法流程</strong><br><code>isSymmetric(root)</code> ：</p>
<ul>
<li>特例处理： 若根节点 <code>root</code> 为空，则直接返回 true 。</li>
<li>返回值： 即 <code>recu(root.left, root.right)</code> ;</li>
</ul>
<p><code>recu(L, R)</code></p>
<ul>
<li>终止条件：<ul>
<li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；<br>当节点 L 值 != 节点 R 值： 此树不对称，因此返回 false ；</li>
</ul>
</li>
<li>递推工作：<ul>
<li>判断两节点 L.left 和 R.right 是否对称，即 <code>recu(L.left, R.right)</code> ；</li>
<li>判断两节点 L.right 和 R.left 是否对称，即 <code>recu(L.right, R.left)</code> ；</li>
</ul>
</li>
<li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</li>
</ul>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 <code>recu()</code> 可以判断一对节点是否对称，因此最多调用 N/2 次 <code>recu()</code> 方法。</li>
<li>空间复杂度 O(N) ： 最差情况下（见下图），二叉树退化为链表，系统使用 O(N) 大小的栈空间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return true;</span><br><span class="line">        return recu(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean recu(TreeNode root1, TreeNode root2)&#123;</span><br><span class="line">        if(root1 &#x3D;&#x3D; null &amp;&amp; root2 &#x3D;&#x3D; null) return true;</span><br><span class="line">        if(root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null) return false;</span><br><span class="line">        if(root1.val !&#x3D; root2.val) return false;</span><br><span class="line">        return recu(root1.left, root2.right) &amp;&amp; recu(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之平衡二叉树"><a href="#二叉树之平衡二叉树" class="headerlink" title="二叉树之平衡二叉树"></a>二叉树之平衡二叉树</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p><strong>二叉树的深度的扩展</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private boolean res &#x3D; true;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null) return true;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private int dfs(TreeNode node)&#123;</span><br><span class="line">        if(res &#x3D;&#x3D; false) return -1;</span><br><span class="line">        if(node &#x3D;&#x3D; null) return 0;</span><br><span class="line">        int leftDepth &#x3D; dfs(node.left);</span><br><span class="line">        int rightDepth &#x3D; dfs(node.right);</span><br><span class="line">        if(Math.abs(leftDepth - rightDepth) &gt; 1)&#123;</span><br><span class="line">            res &#x3D; false;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + Math.max(leftDepth, rightDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之重建二叉树"><a href="#二叉树之重建二叉树" class="headerlink" title="二叉树之重建二叉树"></a>二叉树之重建二叉树</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> class TreeNode &#123;</span><br><span class="line">     int val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        System.out.println(preorder);</span><br><span class="line">        if (preorder.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int len &#x3D; preorder.length;</span><br><span class="line">        int rootVal &#x3D; preorder[0];</span><br><span class="line">        TreeNode ptr &#x3D; new TreeNode(rootVal);</span><br><span class="line">        int rootValIndex &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (rootVal &#x3D;&#x3D; inorder[i])&#123;</span><br><span class="line">                rootValIndex &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] preorder1 &#x3D; Arrays.copyOfRange(preorder, 1, 1 + rootValIndex);</span><br><span class="line">        int[] preorder2 &#x3D; Arrays.copyOfRange(preorder, 1 + rootValIndex, len);</span><br><span class="line">        int[] inorder1 &#x3D; Arrays.copyOfRange(inorder, 0, rootValIndex);</span><br><span class="line">        int[] inorder2 &#x3D; Arrays.copyOfRange(inorder, 1+rootValIndex, len);</span><br><span class="line">        ptr.left &#x3D; buildTree(preorder1, inorder1);</span><br><span class="line">        ptr.right &#x3D; buildTree(preorder2, inorder2);</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>改进，引入哈希表，以空间换时间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     &#x2F;&#x2F; 改进，特征输入用例的考虑，如输入数组为空， 输入数组长度不一</span><br><span class="line">     &#x2F;&#x2F;加入哈希表，以空间换时间</span><br><span class="line">    private Map&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    private int[] preorder;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if (preorder &#x3D;&#x3D; null || preorder.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int len1 &#x3D; preorder.length;</span><br><span class="line">        int len2 &#x3D; inorder.length;</span><br><span class="line">        if (len1 !&#x3D; len2)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        this.preorder &#x3D; preorder;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len1; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return recu(0, len1-1, 0, len2-1);</span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode recu(int preL, int preR, int inL, int inR) &#123;</span><br><span class="line">        if (preL &gt; preR)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode ptr &#x3D;  new TreeNode(preorder[preL]);</span><br><span class="line">       </span><br><span class="line">        int indexIn &#x3D; map.get(preorder[preL]); </span><br><span class="line">        ptr.left &#x3D; recu(preL+1, preL + indexIn - inL, inL, indexIn - 1);</span><br><span class="line">        ptr.right &#x3D; recu(preL + indexIn - inL + 1, preR, indexIn + 1, inR);</span><br><span class="line">        return ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树之-之字形打印二叉树"><a href="#二叉树之-之字形打印二叉树" class="headerlink" title="二叉树之 之字形打印二叉树"></a>二叉树之 之字形打印二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>求解：层次遍历 + 双端队列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if(root &#x3D;&#x3D; null) return res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; deque &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        deque.add(root);</span><br><span class="line">        boolean pos &#x3D; true;</span><br><span class="line">        while(!deque.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            int length &#x3D; deque.size();</span><br><span class="line">            if(pos &#x3D;&#x3D; true)&#123;</span><br><span class="line">                for(int i &#x3D; 0;i &lt; length; i++)&#123;</span><br><span class="line">                    TreeNode poped &#x3D; deque.pollFirst();</span><br><span class="line">                    tmp.add(poped.val);</span><br><span class="line">                    if(poped.left!&#x3D;null) deque.addLast(poped.left);</span><br><span class="line">                    if(poped.right!&#x3D;null) deque.addLast(poped.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for(int i &#x3D; 0;i &lt; length; i++)&#123;</span><br><span class="line">                    TreeNode poped &#x3D; deque.pollLast();</span><br><span class="line">                    tmp.add(poped.val);</span><br><span class="line">                    if(poped.right!&#x3D;null) deque.addFirst(poped.right);</span><br><span class="line">                    if(poped.left!&#x3D;null) deque.addFirst(poped.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            pos &#x3D; !pos;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
